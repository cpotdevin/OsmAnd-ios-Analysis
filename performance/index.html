<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>Performance・Wire iOS and Android App Analysis</title>
        <meta name="description" content="Wire App performance analysis">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" type="text/css" href="/typesafe.css">
        <link rel="stylesheet" type="text/css" href="/index.css">
    </head>
    <body>
        <p><a href="/index.html">Home</a></p>
        <hr>

        <main>
            <h1>Wire App Analysis・Performance</h1>
            <p>To evaluate the performance of both Android and iOS Wire Apps we have defined a couple of scenarios that are likely to have performance problems. During these scenarios we will profile the application using its respective IDE to analyze its performance and identify possible problems. If a problem is identified during the scenarios we will attempt to improve the code in order to mitigate the performance problem. On the other hand if no problem is encountered we will dive into the codebase in an effort to identify the good design practices implemented in the App.</p>

            <h2>Scenarios</h2>
            <ul>
                <li>
                    <a href="#android">Android</a>
                    <ul>
                        <li><a href="#android1">Idle main screen</a></li>
                        <li><a href="#android2">Entering and exiting a conversation</a></li>
                    </ul>
                </li>
                <li>
                    <a href="#ios">iOS</a>
                    <ul>
                        <li><a href="#ios1">Idle main screen</a></li>
                        <li><a href="#ios2">Entering and exiting a conversation</a></li>
                    </ul>
                </li>
            </ul>

            <section>
                <h2 id="android">Android Performance</h2>

                <h3 id="android1">Idle main screen</h3>
                <p>The purpose of this scenario is to determine if the App has any overdraw performance issues.</p>

                <section class="scrolly">
                    <article>
                        <div class="step scrolly1" data-step="0" img-src="/resources/images/android-performance/idle-main-screen/fig00.jpg">
                            <p>This is the screen we will be analyzing; looks pretty right? Let's take a look at it through Android Studio's profiler to see if we find any issues.</p>
                        </div>
                        <div class="step scrolly1" data-step="1" img-src="/resources/images/android-performance/idle-main-screen/fig01.jpg">
                            <p>Everything looks pretty normal: CPU usage is low, memory usage is constant, there are update requests every 30 seconds, and energy usage is low. Lets take a closer look at the memory usage.</p>
                        </div>
                        <div class="step scrolly1" data-step="2" img-src="/resources/images/android-performance/idle-main-screen/fig02.jpg">
                            <p>The dotted line shows the number of allocated objects in the app heap. It appears to be going up at a constant rate and doesn't go down even after a while.</p>
                        </div>
                        <div class="step scrolly1" data-step="3" img-src="/resources/images/android-performance/idle-main-screen/fig03.jpg">
                            <p>Taking a sample of 10 seconds we can see that from 2,966 allocated objects 2,961 were <code>Float</code> objects, but we're not doing anything! Where are these comming from?</p>
                        </div>
                        <div class="step scrolly1" data-step="4" img-src="/resources/images/android-performance/idle-main-screen/fig04.jpg">
                            <p>A closer inspection of these <code>Float</code> objects shows that the code that instantiates them is not part of the app's codebase but part of the Andorid API. Nevertheless, these are instantiated by an <code>ObjectAnimator</code> class so we can start off by looking for instances of these in the code.</p>
                        </div>
                        <div class="step scrolly1" data-step="5" img-src="/resources/images/android-performance/idle-main-screen/fig05.jpg">
                            <p>Now that we know where to look we can go to the CPU profiler to locate the function calls that are instantiating these <code>Float</code> objects. Look at that! The green squares show us that the <code>InfiniteLoadingBarView</code> is the culprit. What is this class for you ask?</p>
                        </div>
                        <div class="step scrolly1" data-step="6" img-src="/resources/images/android-performance/idle-main-screen/fig06.gif">
                            <p>This class is the one in charge of showing the red loading strip at the top of the screen when a message is received and is in the process of being downloaded. As you might have already guessed the problem is that the animation is never stopped even though the View's <code>Visible</code> value is set to <code>GONE</code>.</p>
                        </div>
                        <div class="step scrolly1" data-step="7" img-src="/resources/images/android-performance/idle-main-screen/fig07.jpg" figcaption="java/com/waz/zclient/views/InfiniteLoadingBarView.java">
                            <p>As we can see here the animation is only started when the view is added and stopped only when the view is destroyed, but this view isn't always visible!</p>
                        </div>
                        <div class="step scrolly1" data-step="8" img-src="/resources/images/android-performance/idle-main-screen/fig08.jpg" figcaption="java/com/waz/zclient/views/InfiniteLoadingBarView.java">
                            <p>Solving this problem is easy, first we remove the calls to start the animation when the <code>View</code> is inflated or attached and then we override the <code>setVisibility()</code> method so that it also updates the state of the animator. This solution helps maintain the code contained and simple for external use, i.e. when you hide the loader there is no need to worry about stopping the animation. Now lets rerun a profiling session with this change implemented to see if our solution was effective.</p>
                        </div>
                        <div class="step scrolly1" data-step="9" img-src="/resources/images/android-performance/idle-main-screen/fig09.jpg">
                            <p>Now memory usage is much better, the number of allocated Objects is drastically smaller than before and there are no more <code>Float</code> objects being constantly instantiated.</p>
                        </div>
                        <div class="step scrolly1" data-step="10" img-src="/resources/images/android-performance/idle-main-screen/fig10.jpg">
                            <p>Finally, if we compare the profiling obtained with the patch to the one obtained at the beginning of the exercies we can see an improvement in all measurements except for network usage.</p>
                        </div>
                    </article>

                    <figure class="scrolly1">
                        <figcaption></figcaption>
                        <img src="/resources/images/android-performance/idle-main-screen/fig00.jpg">
                    </figure>
                </section>

                <h3 id="android2">Entering and exiting a conversation</h3>
                <p>The purpose of this scenario is to determine if the App has any memory leaks during the creation and poping of screens.</p>

                <section class="scrolly">
                    <article>
                        <div class="step scrolly2" data-step="0" img-src="/resources/images/android-performance/enter-exit-conversation/fig00.gif">
                            <p>This is the process we will be analyzing: entering and exiting a conversation. Since we are engineers and engineers are lazy by nature lets make a shell script that uses <code>adb</code> and will perform this action repeatedly without having to tap the phone!</p>
                        </div>
                        <div class="step scrolly2" data-step="1" img-src="/resources/images/android-performance/enter-exit-conversation/fig01.jpg">
                            <p>This script taps on two places on the phone in intervals of a second the number of times that is specified by the input parameter. It also tells us how many iterations it has completed after each one. Lets profile the app and run 100 repetitions to see what happens.</p>
                        </div>
                        <div class="step scrolly2" data-step="2" img-src="/resources/images/android-performance/enter-exit-conversation/fig02.jpg">
                            <p>After 100 iterations this is the result. Lets take a closer look at memory usage.</p>
                        </div>
                        <div class="step scrolly2" data-step="3" img-src="/resources/images/android-performance/enter-exit-conversation/fig03.jpg">
                            <p>Looks like we've got a problem.</p>
                        </div>
                    </article>

                    <figure class="scrolly2">
                        <figcaption></figcaption>
                        <img src="/resources/images/android-performance/enter-exit-conversation/fig00.gif">
                    </figure>
                </section>
            </section>

            <section>
                <h2 id="ios">iOS Performance</h2>

                <h3 id="ios1">Idle main screen</h3>

                <h3 id="ios2">Entering and exiting a conversation</h3>
            </section>
        </main>

        <hr>
        <h3>Wire App</h3>
        <ul>
            <li><a href="https://github.com/wireapp">GitHub</a></li>
            <li><a href="https://github.com/wireapp/wire-android">Android repository</a></li>
            <li><a href="https://github.com/wireapp/wire-ios">iOS repository</a></li>
        </ul>

        <script src="/resources/js/d3.min.js"></script>
        <script src="https://unpkg.com/intersection-observer@0.5.1/intersection-observer.js"></script>
        <script src="/resources/js/scrollama.min.js"></script>
        <script src="/scrolly.js"></script>
    </body>
</html>